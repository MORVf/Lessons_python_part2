'''
Вам дано описание наследования классов исключений в следующем формате.
<имя исключения 1> : <имя исключения 2> <имя исключения 3> ... <имя исключения k>
Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.
Антон написал код, который выглядит следующим образом:
try:
   foo()
except <имя 1>:
   print("<имя 1>")
except <имя 2>:
   print("<имя 2>")

Костя посмотрел на этот код и указал Антону на то, что некоторые исключения можно не ловить, так как ранее в коде будет пойман их предок.
Но Антон не помнит какие исключения наследуются от каких. Помогите ему выйти из неловкого положения и напишите программу, которая будет 
определять обработку каких исключений можно удалить из кода.
Типы исключений не созданы, создавать классы исключений также не требуется.
Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и не ловить, потому что мы уже ранее где-то поймали их предка.

Формат входных данных:
В первой строке входных данных содержится целое число n - число классов исключений.
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й класс. Обратите внимание, 
что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или косвенно), что класс не наследуется 
явно от одного класса более одного раза.
В следующей строке содержится число m - количество обрабатываемых исключений.
Следующие m строк содержат имена исключений в том порядке, в каком они были написаны у Антона в коде.
Гарантируется, что никакое исключение не обрабатывается дважды.

Формат выходных данных:
Выведите в отдельной строке имя каждого исключения, обработку которого можно удалить из кода, не изменив при этом поведение программы. Имена 
следует выводить в том же порядке, в котором они идут во входных данных.

Sample Input:
4
ArithmeticError
ZeroDivisionError : ArithmeticError
OSError
FileNotFoundError : OSError
4
ZeroDivisionError
OSError
ArithmeticError
FileNotFoundError

Sample Output:
FileNotFoundError
'''

n = int(input())  # считываем количество строк для ввода классов исключений
dict_classes = {}  # словарь для хранения исключений
temp_lst_exceptions = []  # список для хранения исключений, которые необходимо проверить на нужность 
lst_with_fail_exceptions = []  # список исключений, которые были выброшены из-за ненужности


def is_useless_exception(error):  # функция проверки нужности исключения
    global is_root_exception  # глобальная переменная
    global lst_with_fail_exceptions  # глобальная переменная
    for parent in dict_classes:  # пробегаем все ключи словаря
        if error in dict_classes[parent]:  # если нашли такой ключ, у которого значение == исключению
            if parent in temp_lst_exceptions:  # если ключ-исключение присутствует в списке на проверку
                if temp_lst_exceptions.index(parent) < temp_lst_exceptions.index(is_root_exception):  # если индекс предка меньше индекса исключения
                    if is_root_exception not in lst_with_fail_exceptions:  # если исключение ещё не помечено как ненужное
                        lst_with_fail_exceptions += [is_root_exception]  # то добавляем его в список ненужных
                        return print(is_root_exception)  # выводим исключение
            else:  # иначе
                is_useless_exception(parent)  # вызываем рекурсивно функцию проверки нужности исключения по саб-классу


def add_subclass_in_parent():  # функция добавления исключений
    for ind_cls in range(2, len(lst_cls)):  # пробегаем все элементы входящего списка после ":"
        if lst_cls[ind_cls] not in dict_classes:  # если такой строки-ключа нет в словаре, то
            dict_classes[lst_cls[ind_cls]] = []  # добавляем его в словарь
        for key in dict_classes.keys():  # пробегаем все ключи словаря
            if key == lst_cls[ind_cls]:  # при совпадении ключа-родителя с элементом списка
                dict_classes[key] += [lst_cls[0]]  # добавляем к родителю нового наследника


for i in range(n):
    lst_cls = input().split()  # считываем строки-списки
    if lst_cls[0] not in dict_classes:  # если в списке есть первый элемент, которого нет в словаре,
        dict_classes[lst_cls[0]] = []  # то добавляем его в словарь

    if ':' in lst_cls:  # если в списке есть символ ":", то
        add_subclass_in_parent()  # вызываем функцию добавления исключений

m = int(input())  # считываем количество строк, в которых будут указывать исключения

for j in range(m):
    str_exception = input()  # считываем строки с исключениями
    if str_exception not in lst_with_fail_exceptions:  # если исключения ещё нет в списке ненужных
        if str_exception not in dict_classes or str_exception in temp_lst_exceptions:  # если исключения нет в словаре наследований или исключение уже использовалось
            lst_with_fail_exceptions += [str_exception]  # добавляем его в список ненужных
            print(str_exception)  # выводим исключение
        else:  # иначе
            temp_lst_exceptions += [str_exception]  # добавляем его в список, требующий проверки на нужность
            if len(temp_lst_exceptions) > 1:  # если в списке более 1 элемента, то
                is_root_exception = str_exception  # запоминаем первичное входящее исключение
                is_useless_exception(str_exception)  # вызываем функцию проверки
