"""Текст задания.

Вам дано описание наследования классов в следующем формате.
<имя класса 1> : <имя класса 2> <имя класса 3> ... <имя класса k>
Это означает, что класс 1 отнаследован от класса 2, класса 3, и т. д.
Класс A является прямым предком класса B, если B отнаследован от A.
Класс A является предком класса B, если:
- A = B;
- A - прямой предок B
- существует такой класс C, что C - прямой предок B и A - предок C

Вам необходимо отвечать на запросы, является ли один класс предком другого класса.

Важное примечание:
Создавать классы не требуется.
Мы просим вас промоделировать этот процесс, и понять существует ли путь от одного класса до другого.

Формат входных данных:
В первой строке входных данных содержится целое число n - число классов.
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов 
наследуется i-й класс. Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, 
что класс не наследуется сам от себя (прямо или косвенно), что класс не наследуется явно от одного класса 
более одного раза.
В следующей строке содержится число q - количество запросов.
В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
Формат выходных данных:
Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", 
если не является.

Sample Input:
4
A
B : A
C : A
D : B C
4
A B
B D
C D
D A

Sample Output:
Yes
Yes
Yes
No

"""

__all__ = ['is_parent', 'add_subclass_in_parent', 'dict_classes']
__version__ = '1.0.0'
__author__ = 'Evgenii Mayorov'

dict_classes = {}


def is_parent(parent, heir):
    """Функция, определяющая наличие связи предок-наследник у классов."""
    global is_heir
    global is_end_cycle   #глобальная переменная, говорящая завершился ли поиск наследника по всем подклассам класса-предка
    global is_root_parent   #глобальная переменная, хранящая в себе начального предка, у которого ищется наследник
    if heir in dict_classes[parent]:   #если наследник есть в первичных подклассах родителя
        is_heir = True   #наследник найден
        return print('Yes')
    elif len(dict_classes[parent]) > 0:   #иначе, если есть иные подклассы у родителя, то ищем наследника в них
        is_end_cycle = False    #начинаем цикл сначала
        for value in dict_classes[parent]:    #пробегаем по одному каждый подкласс
            if is_heir is False:    #если до этого момента Наследник не найден, то
                is_parent(value, heir)    #вызываем рекурсивно поиск наследника в подклассах подкласса предка
        if parent == is_root_parent and is_heir is False:    #если во всех подклассах подклассов предка не нашлось наследника, то
            return print('No')
    elif is_end_cycle is True:   #если подклассов нет и наследник не найден, то
        return print('No')


def add_subclass_in_parent():
    """Функция добавления классов и наследований."""
    for ind_cls in range(2, len(lst_cls)):    #пробегаем все элементы входящего списка после ":"
        if lst_cls[ind_cls] not in dict_classes:    #если такой строки-ключа нет в словаре, то
            dict_classes[lst_cls[ind_cls]] = []    #добавляем его в словарь
        for key in dict_classes.keys():
            if key == lst_cls[ind_cls]:     #при совпадении ключа-родителя с элементом списка
                dict_classes[key] += [lst_cls[0]]    #добавляем к родителю нового наследника 


if __name__ == "__main__":
    
    n = int(input())
    
    for i in range(n):
        lst_cls = input().split()   #считываем строки-списки
        if lst_cls[0] not in dict_classes:    #если в списке есть первый элемент, которого нет в словаре,
            dict_classes[lst_cls[0]] = []     # то добавляем его в словарь

        if ':' in lst_cls:   # если в списке есть символ ":", то
            add_subclass_in_parent()   #вызываем функцию добавления классов и наследований

    q = int(input())

    for j in range(q):
        lst_with_classes = input().split()   #считываем строки-списки для проверки связи наследования
        if lst_with_classes[0] == lst_with_classes[1]:    #если предок == наследнику, то
            print('Yes')
        elif lst_with_classes[0] in dict_classes and lst_with_classes[1] in dict_classes:   #если предок != наследнику, но они оба есть в словаре, то
            is_heir = False   #выставляем "наследник не найден"
            is_end_cycle = True   #выставляем "поиск наследника завершился по всем подклассам класса-предка"
            is_root_parent = lst_with_classes[0]   #сохраняем начального предка, у которого ищется наследник
            is_parent(lst_with_classes[0], lst_with_classes[1])   #вызываем функцию определения наследственности
        else:   #если предок != наследнику и при этом кого-то из них нет в ключах словаря, то
            print('No')
