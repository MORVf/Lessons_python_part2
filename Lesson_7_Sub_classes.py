"""Текст задания.

Вам дано описание наследования классов в следующем формате.
<имя класса 1> : <имя класса 2> <имя класса 3> ... <имя класса k>
Это означает, что класс 1 отнаследован от класса 2, класса 3, и т. д.
Класс A является прямым предком класса B, если B отнаследован от A.
Класс A является предком класса B, если:
- A = B;
- A - прямой предок B
- существует такой класс C, что C - прямой предок B и A - предок C

Вам необходимо отвечать на запросы, является ли один класс предком другого класса.

Важное примечание:
Создавать классы не требуется.
Мы просим вас промоделировать этот процесс, и понять существует ли путь от одного класса до другого.

Формат входных данных:
В первой строке входных данных содержится целое число n - число классов.
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов 
наследуется i-й класс. Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, 
что класс не наследуется сам от себя (прямо или косвенно), что класс не наследуется явно от одного класса 
более одного раза.
В следующей строке содержится число q - количество запросов.
В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
Формат выходных данных:
Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", 
если не является.

Sample Input:
4
A
B : A
C : A
D : B C
4
A B
B D
C D
D A

Sample Output:
Yes
Yes
Yes
No

Используемые функции: is_parent, add_subclass_in_parent.

"""

__version__ = '1.0.0'
__author__ = 'Evgenii Mayorov'

dict_classes = {}


def is_parent(parent, heir):
    """Функция, определяющая наличие связи предок-наследник у классов.
    
    Аргументы:
    parent - вероятный предок
    heir - вероятный наследник
    
    Возвращает либо Yes, либо No.
    """
    global is_heir
    global is_end_cycle
    global is_root_parent
    if heir in dict_classes[parent]:  # если наследник есть в первичных подклассах родителя
        is_heir = True  # наследник найден
        return print('Yes')
    elif len(dict_classes[parent]) > 0:  # если есть иные подклассы у родителя, то ищем наследника в них
        is_end_cycle = False  # начинаем цикл сначала
        for value in dict_classes[parent]:  # пробегаем по одному каждый подкласс
            if not is_heir:  # если до этого момента Наследник не найден, то
                is_parent(value, heir)  # вызываем рекурсивно поиск наследника в подклассах подкласса предка
        if parent == is_root_parent and is_heir is False:  # если во всех подклассах подклассов предка не нашлось наследника
            return print('No')
    elif is_end_cycle is True:  # если подклассов нет и наследник не найден
        return print('No')


def add_subclass_in_parent():
    """Функция добавления классов и наследований.
    
    Аргументы отсутствуют, возвращает None.
    
    """
    for ind_cls in range(2, len(lst_cls)):  # пробегаем все элементы входящего списка после ":"
        if lst_cls[ind_cls] not in dict_classes:
            dict_classes[lst_cls[ind_cls]] = []
        for key in dict_classes.keys():
            if key == lst_cls[ind_cls]:
                dict_classes[key] += [lst_cls[0]] 

    
n = int(input())
    
for i in range(n):
    lst_cls = input().split()
    if lst_cls[0] not in dict_classes:
        dict_classes[lst_cls[0]] = []

    if ':' in lst_cls:
        add_subclass_in_parent()

q = int(input())

for j in range(q):
    lst_with_classes = input().split()
    if lst_with_classes[0] == lst_with_classes[1]:  # если предок == наследнику
        print('Yes')
    # если предок != наследнику, но они оба есть в словаре
    elif lst_with_classes[0] in dict_classes and lst_with_classes[1] in dict_classes:
        is_heir = False  # выставляем "наследник не найден"
        is_end_cycle = True  # выставляем "поиск наследника завершился по всем подклассам класса-предка"
        is_root_parent = lst_with_classes[0]  # сохраняем начального предка, у которого ищется наследник
        is_parent(lst_with_classes[0], lst_with_classes[1])
    else:
        print('No')
